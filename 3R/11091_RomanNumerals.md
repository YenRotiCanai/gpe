# 條件
- 從左到右，降序（小到大），加起來
- 如果小的先才到大的，那就是大的減小的（小->大 = 大 - 小）

- I(1) 只能跟 V(5) 和 X(10) 一起。(IV = 4)
    也就是說 I(1) 的左右之能是 V(5) 或者 X(10)
- X(10) 只能跟 L(50) 和 C(100)
- C(100) 只能跟 D(500) 和 M(1000)
- V(5), L(50), D(500) 後面總是跟著比較小的，所以直接加到總額裡面
- I, X, C, M 不能出現超過 3 次
- V, L, D 不能超過 1 次

- 只用大寫

eg.
XXV = 25
10 + 10 + 5 = 25

4 = IV
5 - 1 = 4

942 = CM XL II
(1000 - 100) + (50 - 10) + 2 = 942

MCMLXXXIII = M CM L X X X III = 1000 + 900 + 50 + 30 + 3 = 1983

# 想法
看起來要倒過來做

羅馬 -> 數字
開一個 int tmp 來吃
- 只要遇到比自己小的，就減掉他，然後和自己加起來
- 只要遇到比自己大的，就把身上的加到 sum 裡面，然後 tmp 變成那個大的

- 只要遇到比自己小的，就減掉他，然後加進 sum
- 只要遇到比自己大的，就直接把自己加進 sum

數字 -> 羅馬
判斷位數（digit place) 的方法：直接乘上每個位數所代表的數字，譬如：個位數就是 *1，十位數 *10，百位數 *100
942 倒過來 = 249
宣告一個 int d 位數，一開始是 1，每回合 *10
i = 0, d = 1, v = 2, final = 1*2 = 2
i = 1, d = 10, v = 4, final = 40
i = 2, d = 100, v = 9, final = 900

# 別人的做法

MMMCMXL